# INDEX

## Qu’est-ce qu’un INDEX ?
Un **index** est un objet physique utilisé pour **accélérer l’accès aux données** en facilitant l’exécution des requêtes sur une table. Il agit comme un guide permettant de localiser rapidement les informations sans parcourir l’ensemble des données.

## Création d’un INDEX
Un index peut être créé à l’aide de la commande suivante :

```sql
CREATE INDEX index_name ON table_name(column_name);
```

**Exemple :**

```sql
CREATE INDEX user_id ON user(id);
```

## Utilité d’un INDEX

### Test avant la création de l’index :

```sql
SELECT * FROM user WHERE id = 1000;
-- Temps de réponse : 1760,017 ms
```

### Test après la création de l’index :

```sql
SELECT * FROM user WHERE id = 1000;
-- Temps de réponse : 27,711 ms
```

**Résultat :** Le temps de réponse est considérablement réduit après la création de l’index.

## Inconvénients des INDEX
Malgré leurs avantages, les index présentent certains inconvénients :
- Ils **ralentissent les opérations d’écriture** (INSERT, UPDATE, DELETE).
- Ils **consomment de la mémoire supplémentaire**.
- Ils peuvent **dégrader les performances** dans certains cas, notamment lors d’importants volumes d’insertion.

### Exemple d’impact sur les performances d’insertion

La fonction `generate_series(min, max)` permet de générer une liste de nombres entre `min` et `max`.

#### Insertion sans index :

```sql
CREATE TABLE test3 (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    valeur INTEGER,
    commentaire TEXT
);
INSERT INTO test3 (valeur, commentaire)
SELECT i, 'commentaire ' || i FROM generate_series(1, 10000000) i;
-- Durée : 14 758,503 ms (00:14,759)
```

#### Insertion avec index :

```sql
CREATE INDEX idx_test2_commentaire ON test2 (commentaire);
INSERT INTO test2 (valeur, commentaire)
SELECT i, 'commentaire ' || i FROM generate_series(1, 10000000) i;
-- Durée : 207 075,335 ms (03:27,075)
```

**Conclusion :** L’ajout d’un index peut **ralentir considérablement les insertions massives**.

## Impact mémoire
Un index augmente la consommation d’espace disque :

```sql
SELECT pg_size_pretty(pg_relation_size('test2')) AS "Taille Table",
       pg_size_pretty(pg_indexes_size('test2')) AS "Taille Index";

-- Taille Table | Taille Index
-- ------------+-------------
-- 574 MB      | 816 MB
```

**Observation :** La taille occupée par les index peut dépasser celle de la table elle-même.

## Contraintes pratiques liées aux INDEX
La création d’un index peut **bloquer temporairement les écritures** :

```sql
-- Bloque les écritures
CREATE INDEX ON matable (macolonne);

-- Ne bloque pas mais plus lent et risque d’échec
CREATE INDEX CONCURRENTLY ON matable (macolonne);
```

## Réindexation
La réindexation permet de reconstruire les index pour optimiser les performances :

```sql
REINDEX INDEX pgbench_accounts_bid_idx;  -- Un seul index
REINDEX TABLE pgbench_accounts;          -- Tous les index d'une table
REINDEX (VERBOSE) DATABASE pgbench;      -- Tous les index de la base avec détails
```

## Types d’INDEX dans PostgreSQL
- **B-tree** (équilibré) : type par défaut.
- **UNIQUE** : garantit l’unicité des valeurs.
- **Multicolonne, fonctionnel, partiel, couvrant.**
- **Index spécialisés** : Hash, GiST, GIN, BRIN, HNSW, etc.

## Structure d’un INDEX
Un index associe des **clés** à des **localisations** (pages mémoire) à l’aide d’une structure distincte de la table.

**Analogie :**
- Fiches en carton dans une bibliothèque : **B-tree**
- Index à la fin d’un livre technique : **GIN**

## Index multicolonne
Il est possible d’indexer plusieurs colonnes :

```sql
CREATE INDEX ON ma_table (id, name);
```

**L’ordre des colonnes est important.**  
L’accès direct est optimisé uniquement sur les **premières colonnes**.

**Exemple :**

```sql
CREATE TABLE t1 (c1 int, c2 int, c3 int, c4 text);
INSERT INTO t1 (c1, c2, c3, c4)
SELECT i*10, j*5, k*20, 'text'||i||j||k
FROM generate_series(1,100) i
CROSS JOIN generate_series(1,100) j
CROSS JOIN generate_series(1,100) k;

CREATE INDEX ON t1 (c1, c2, c3);
VACUUM ANALYZE t1;
```

## Types de scans utilisant un index
- **Index Scan**
- **Bitmap Index Scan**
- **Index Only Scan** (très performant)
- Versions parallélisées disponibles

## Index fonctionnels
Un index classique ne sera pas utilisé si une fonction est appliquée à la colonne dans la clause WHERE :

```sql
SELECT * FROM ma_table WHERE upper(a) = 'DUPOND';
```

**Solution :** Créer un index fonctionnel :

```sql
CREATE INDEX mon_idx ON ma_table (upper(a));
```

## Index couvrants
Les index couvrants optimisent les **Index Only Scans** en incluant des colonnes supplémentaires :

```sql
CREATE UNIQUE INDEX clients_idx1
ON clients (id_client) INCLUDE (nom_client);
```

Cet index permet d’exécuter efficacement la requête suivante :

```sql
SELECT id_client, nom_client FROM clients WHERE id_client > 100;
```

## Classes d’opérateurs
Les index s’appuient sur des classes d’opérateurs adaptées :

```sql
WHERE col_varchar LIKE 'chaine%'
```

Un index standard ne sera pas utilisé. Il faut créer un index spécifique :

```sql
CREATE INDEX idx1
ON ma_table (col_varchar varchar_pattern_ops);
```

Cela permet d’optimiser les recherches textuelles sans dépendre des règles de collation.