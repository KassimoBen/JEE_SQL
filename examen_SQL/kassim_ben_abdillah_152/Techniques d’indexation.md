# INDEX

## Qu'est-ce qu'un INDEX ?
Un index est un objet physique qui accélère l’accès aux données en optimisant les requêtes sur une table.

## Création d’un INDEX
```sql
CREATE INDEX index_name ON table_name(column_name);
```
### Exemple :
```sql
CREATE INDEX user_id ON user(id);
```

## Utilisation d’un INDEX
### Premier test avant la création d’un index :
```sql
SELECT * FROM user WHERE id = 1000;
-- Temps de réponse : 1760,017 ms
```
### Deuxième test après la création d’un index :
```sql
SELECT * FROM user WHERE id = 1000;
-- Temps de réponse : 27,711 ms
```

## Inconvénients des INDEX
- Un index **ralentit les écritures** (INSERT, UPDATE, DELETE).
- Il **occupe de la mémoire supplémentaire**.
- Il **n'est pas gratuit en termes de performance**.

### Exemple de ralentissement :
La fonction `generate_series(min, max)` permet de générer une liste de nombres entre `min` et `max`.

#### Test d’insertion sans index :
```sql
CREATE TABLE test3 (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    valeur INTEGER,
    commentaire TEXT
);
INSERT INTO test3 (valeur, commentaire)
SELECT i, 'commentaire ' || i FROM generate_series(1, 10000000) i;
-- Durée : 14 758,503 ms (00:14,759)
```

#### Test d’insertion avec index :
```sql
CREATE INDEX idx_test2_commentaire ON test2 (commentaire);
INSERT INTO test2 (valeur, commentaire)
SELECT i, 'commentaire ' || i FROM generate_series(1, 10000000) i;
-- Durée : 207 075,335 ms (03:27,075)
```
**Conclusion :** L’ajout d’un index ralentit considérablement l’insertion des données.

## Impact sur la mémoire
Taille mémoire occupée par une table avec et sans index :
```sql
SELECT pg_size_pretty(pg_relation_size('test2')),
       pg_size_pretty(pg_indexes_size('test2'));

-- pg_size_pretty | pg_size_pretty
-- --------------+----------------
-- 574 MB        | 816 MB
```
L'index occupe plus d'espace en mémoire.

## Contraintes pratiques des INDEX
```sql
-- Bloque les écritures !
CREATE INDEX ON matable (macolonne);

-- Ne bloque pas, mais peut échouer
CREATE INDEX CONCURRENTLY ON matable (macolonne);
```

## Réindexation
```sql
REINDEX INDEX pgbench_accounts_bid_idx;  -- Un seul index
REINDEX TABLE pgbench_accounts;          -- Tous les index d'une table
REINDEX (VERBOSE) DATABASE pgbench;      -- Tous les index de la base avec détails
```

## Types d’INDEX dans PostgreSQL
- **B-tree (équilibré)** : par défaut
- **UNIQUE** : pour assurer l’unicité des valeurs (préférer la contrainte `UNIQUE`)
- **Multicolonne, fonctionnel, partiel, couvrant**
- **Index spécialisés** : Hash, GiST, GIN, BRIN, HNSW…

## Structure d’un INDEX
- Associe des **clés (termes)** à des **localisations (pages)**
- Structure spécialisée, distincte de la table
- Analogies :
  - Fiches en carton des bibliothèques avant l’informatique (**B-tree**)
  - Index d’un livre technique (**GIN**)

## Index multicolonne
On peut indexer plusieurs colonnes :
```sql
CREATE INDEX ON ma_table (id, name);
```
- **L’ordre des colonnes est crucial**.
- Un accès direct est possible **uniquement sur les premières colonnes**.

### Exemple :
```sql
CREATE TABLE t1 (c1 int, c2 int, c3 int, c4 text);
INSERT INTO t1 (c1, c2, c3, c4)
SELECT i*10, j*5, k*20, 'text'||i||j||k
FROM generate_series(1,100) i
CROSS JOIN generate_series(1,100) j
CROSS JOIN generate_series(1,100) k;

CREATE INDEX ON t1 (c1, c2, c3);
VACUUM ANALYZE t1;
```

## Types de scans utilisant un index
- **Index Scan**
- **Bitmap Scan**
- **Index Only Scan** (idéal pour les performances)
- Versions parallélisées disponibles

## Index fonctionnels
Un index classique est inutilisable si une fonction est appliquée sur la colonne :
```sql
SELECT * FROM ma_table WHERE upper(a) = 'DUPOND';
```
Solution : créer un index sur la fonction :
```sql
CREATE INDEX mon_idx ON ma_table (upper(a));
```

## Index couvrants
Utilisés pour optimiser les **Index Only Scans** :
```sql
CREATE UNIQUE INDEX clients_idx1
ON clients (id_client) INCLUDE (nom_client);
```
Cet index permet d’accélérer la requête suivante :
```sql
SELECT id_client, nom_client FROM clients WHERE id_client > 100;
```

## Classes d’opérateurs
Les index utilisent des opérateurs spécifiques :
```sql
WHERE col_varchar LIKE 'chaine%'
```
Dans ce cas, un index standard est inutilisable. Solution :
```sql
CREATE INDEX idx1
ON ma_table (col_varchar varchar_pattern_ops);
```
Cela optimise la recherche textuelle en supprimant la dépendance aux collations.

---